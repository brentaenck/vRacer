<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Minimal Racing Line Editor</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; background: #1a1a1a; color: #e0e0e0; }
        #trackCanvas { border: 2px solid #555; background: #f8f9fa; display: block; margin: 20px auto; }
        .controls { text-align: center; margin: 20px; }
        .controls button { margin: 5px; padding: 10px 15px; background: #4CAF50; color: white; border: none; border-radius: 4px; cursor: pointer; }
        .controls button:hover { background: #45a049; }
        #status { text-align: center; margin: 10px; padding: 10px; background: #333; border-radius: 4px; }
        .error { color: #ff4444; }
        .success { color: #44ff44; }
    </style>
</head>
<body>
    <h1>Minimal Racing Line Editor</h1>
    <div class="controls">
        <button onclick="loadAndRender()">Load & Render Track</button>
        <button onclick="clearCanvas()">Clear</button>
        <button onclick="testCanvas()">Test Canvas</button>
    </div>
    <canvas id="trackCanvas" width="1000" height="700"></canvas>
    <div id="status">Ready</div>

    <script>
        const canvas = document.getElementById('trackCanvas');
        const ctx = canvas.getContext('2d');
        const status = document.getElementById('status');
        
        let trackData = null;
        
        function log(message, type = 'info') {
            console.log(message);
            status.innerHTML = `<span class="${type}">${message}</span>`;
        }

        function testCanvas() {
            log('Testing canvas drawing...', 'info');
            
            // Clear canvas
            ctx.fillStyle = '#f8f9fa';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Draw test shapes
            ctx.fillStyle = '#4CAF50';
            ctx.fillRect(50, 50, 100, 100);
            
            ctx.fillStyle = '#FF4444';
            ctx.beginPath();
            ctx.arc(300, 100, 50, 0, 2 * Math.PI);
            ctx.fill();
            
            ctx.fillStyle = '#000';
            ctx.font = '20px Arial';
            ctx.fillText('Canvas Working!', 400, 100);
            
            log('Canvas test complete - shapes should be visible', 'success');
        }

        async function loadAndRender() {
            try {
                log('Loading track data...', 'info');
                
                const response = await fetch('data/track-geometry.json');
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                trackData = await response.json();
                log(`Loaded: ${trackData.metadata.name}`, 'success');
                
                renderTrack();
                
            } catch (error) {
                log(`Error: ${error.message}`, 'error');
            }
        }

        function renderTrack() {
            if (!trackData) {
                log('No track data loaded', 'error');
                return;
            }
            
            log('Rendering track...', 'info');
            
            // Clear canvas
            ctx.fillStyle = '#f8f9fa';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Calculate scale and offset to center track
            const bounds = trackData.track.bounds.track;
            const trackWidth = bounds.maxX - bounds.minX;
            const trackHeight = bounds.maxY - bounds.minY;
            
            const padding = 50;
            const scaleX = (canvas.width - padding * 2) / trackWidth;
            const scaleY = (canvas.height - padding * 2) / trackHeight;
            const scale = Math.min(scaleX, scaleY);
            
            const scaledTrackWidth = trackWidth * scale;
            const scaledTrackHeight = trackHeight * scale;
            const offsetX = (canvas.width - scaledTrackWidth) / 2 - bounds.minX * scale;
            const offsetY = (canvas.height - scaledTrackHeight) / 2 - bounds.minY * scale;
            
            log(`Scale: ${scale.toFixed(2)}, Offset: (${offsetX.toFixed(1)}, ${offsetY.toFixed(1)})`, 'info');
            
            // Draw track surface (fill between outer and inner)
            ctx.save();
            
            // Fill outer area
            ctx.beginPath();
            const outer = trackData.track.outer;
            ctx.moveTo(outer[0].x * scale + offsetX, outer[0].y * scale + offsetY);
            for (let i = 1; i < outer.length; i++) {
                ctx.lineTo(outer[i].x * scale + offsetX, outer[i].y * scale + offsetY);
            }
            ctx.closePath();
            ctx.fillStyle = '#4a5568';
            ctx.fill();
            
            // Cut out inner area
            ctx.globalCompositeOperation = 'destination-out';
            ctx.beginPath();
            const inner = trackData.track.inner;
            ctx.moveTo(inner[0].x * scale + offsetX, inner[0].y * scale + offsetY);
            for (let i = 1; i < inner.length; i++) {
                ctx.lineTo(inner[i].x * scale + offsetX, inner[i].y * scale + offsetY);
            }
            ctx.closePath();
            ctx.fill();
            
            ctx.restore();
            
            // Draw track boundaries
            ctx.strokeStyle = '#2d3748';
            ctx.lineWidth = 3;
            
            // Outer boundary
            ctx.beginPath();
            ctx.moveTo(outer[0].x * scale + offsetX, outer[0].y * scale + offsetY);
            for (let i = 1; i < outer.length; i++) {
                ctx.lineTo(outer[i].x * scale + offsetX, outer[i].y * scale + offsetY);
            }
            ctx.closePath();
            ctx.stroke();
            
            // Inner boundary
            ctx.beginPath();
            ctx.moveTo(inner[0].x * scale + offsetX, inner[0].y * scale + offsetY);
            for (let i = 1; i < inner.length; i++) {
                ctx.lineTo(inner[i].x * scale + offsetX, inner[i].y * scale + offsetY);
            }
            ctx.closePath();
            ctx.stroke();
            
            // Draw start/finish line
            const startLine = trackData.track.startLine;
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.moveTo(startLine.a.x * scale + offsetX, startLine.a.y * scale + offsetY);
            ctx.lineTo(startLine.b.x * scale + offsetX, startLine.b.y * scale + offsetY);
            ctx.stroke();
            
            // Draw racing line
            const waypoints = trackData.racingLine.waypoints;
            
            // Draw line connections
            ctx.strokeStyle = '#4CAF50';
            ctx.lineWidth = 3;
            ctx.beginPath();
            if (waypoints.length > 0) {
                ctx.moveTo(waypoints[0].pos.x * scale + offsetX, waypoints[0].pos.y * scale + offsetY);
                for (let i = 1; i < waypoints.length; i++) {
                    ctx.lineTo(waypoints[i].pos.x * scale + offsetX, waypoints[i].pos.y * scale + offsetY);
                }
                // Connect back to first point
                ctx.lineTo(waypoints[0].pos.x * scale + offsetX, waypoints[0].pos.y * scale + offsetY);
            }
            ctx.stroke();
            
            // Draw waypoints
            waypoints.forEach((wp, index) => {
                const x = wp.pos.x * scale + offsetX;
                const y = wp.pos.y * scale + offsetY;
                
                let color;
                switch (wp.cornerType) {
                    case 'straight': color = '#2196F3'; break;
                    case 'entry': color = '#FF9800'; break;
                    case 'apex': color = '#F44336'; break;
                    case 'exit': color = '#4CAF50'; break;
                    default: color = '#9E9E9E';
                }
                
                ctx.beginPath();
                ctx.arc(x, y, 6, 0, 2 * Math.PI);
                ctx.fillStyle = color;
                ctx.fill();
                
                if (wp.brakeZone) {
                    ctx.strokeStyle = '#FF5722';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                }
            });
            
            log(`Track rendered successfully with ${waypoints.length} waypoints!`, 'success');
        }

        function clearCanvas() {
            ctx.fillStyle = '#f8f9fa';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            log('Canvas cleared', 'info');
        }
        
        // Auto-load on page ready
        document.addEventListener('DOMContentLoaded', () => {
            log('Page loaded. Click "Load & Render Track" to test.', 'info');
        });
    </script>
</body>
</html>
